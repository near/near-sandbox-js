{"version":3,"sources":["../src/sandbox/config.ts","../src/errors.ts","../src/binary/binaryUtils.ts","../src/binary/binaryExecution.ts","../src/binary/binary.ts","../src/sandbox/sandboxUtils.ts","../src/sandbox/Sandbox.ts"],"sourcesContent":["import { NEAR } from \"@near-js/tokens\";\nimport { join } from \"path\";\nimport { apply } from \"json-merge-patch\"\nimport * as fs from \"fs/promises\";\nimport { SandboxErrors, TypedError } from \"../errors\";\n\n/*\n  * Network specific configurations used to modify behavior inside a chain.\n  * This is so far only useable with sandbox networks since it would require\n  * direct access to a node to change the config. Each network like mainnet\n  * and testnet already have pre-configured settings; meanwhile sandbox can\n  * have additional settings on top of them to facilitate custom behavior\n  * such as sending large requests to the sandbox network.\n  */\n\nexport const DEFAULT_ACCOUNT_ID = 'sandbox';\nexport const DEFAULT_PUBLIC_KEY = 'ed25519:5BGSaf6YjVm7565VzWQHNxoyEjwr3jUpRJSGjREvU9dB';\nexport const DEFAULT_PRIVATE_KEY = 'ed25519:3tgdk2wPraJzT4nsTuf86UX41xgPNk3MHnq8epARMdBNs29AFEztAuaQ7iHddDfXG9F2RzV1XNQYgJyAyoW51UBB';\nexport const DEFAULT_BALANCE = NEAR.toUnits(10000);\n\n/*\n  * Represents a genesis account in the NEAR sandbox.\n  * Means it will saved as starting account in the genesis.json file.\n  * accountId - The unique identifier for the account, it`s can be top-level account or sub-account.(e.g. \"alice.near\", \"alice\")\n  * publicKey - The public part of the privateKey that will control the account.\n  * privateKey - The private key used to sign transactions for the account.\n  * balance - The initial balance of the account in yoctoNEAR.\n  */\nexport class GenesisAccount {\n  accountId: string;\n  publicKey: string;\n  privateKey: string;\n  balance: bigint;\n\n  constructor(accountId: string, publicKey: string, privateKey: string, balance: bigint) {\n    this.accountId = accountId;\n    this.publicKey = publicKey;\n    this.privateKey = privateKey;\n    this.balance = balance;\n  }\n\n  /**\n   * Creates a default genesis account with predefined values.\n   * This is useful for testing and development purposes.\n   *\n   * @param accountId Optional custom account ID, defaults to DEFAULT_ACCOUNT_ID.\n   * @returns A GenesisAccount instance with default values.\n   */\n  static createDefault(accountId?: string): GenesisAccount {\n    return new GenesisAccount(\n      accountId ?? DEFAULT_ACCOUNT_ID,\n      DEFAULT_PUBLIC_KEY,\n      DEFAULT_PRIVATE_KEY,\n      DEFAULT_BALANCE\n    );\n  }\n}\n\n/**\n * Configuration options for the NEAR sandbox environment.\n * This interface allows customization of the sandbox's behavior.\n * @property rpcPort - Port that RPC will be bound to. Will be picked randomly if not set.\n * @property netPort - Port that the network will be bound to. Will be picked randomly if not set.\n * @property additionalConfig - Additional JSON configuration to merge with the default config. Ensure that the additional properties are correct.\n * @property additionalGenesis - Additional genesis parameters to modify the genesis.json.\n * @property additionalAccounts - Additional accounts to be passed in the sandbox genesis. By default, it will create a default account with 10,000 NEAR.\n * @property nodeKey - Node key to be used by the sandbox node. If not provided, a default key will be used. Should match up with node key in genesis.json.\n * @property validatorKey - Validator key to be used by the validator. Should match up with validator key in genesis.json.\n */\nexport interface SandboxConfig {\n  rpcPort?: number;\n  netPort?: number;\n  additionalConfig?: Record<string, any>;\n  additionalGenesis?: Record<string, any>;\n  additionalAccounts?: GenesisAccount[];\n  nodeKey?: Record<string, any>;\n  validatorKey?: Record<string, any>;\n}\n\nexport async function overrideConfigs(homeDir: string, config?: SandboxConfig): Promise<void> {\n  await setSandboxGenesis(homeDir, config);\n\n  await setSandboxConfig(homeDir, config);\n  if (config?.nodeKey) {\n    await fs.writeFile(join(homeDir, \"node_key.json\"), JSON.stringify(config.nodeKey, null, 2), 'utf-8');\n  }\n  if (config?.validatorKey) {\n    await fs.writeFile(join(homeDir, 'validator_key.json'), JSON.stringify(config.validatorKey, null, 2), 'utf-8');\n  }\n}\nexport async function setSandboxGenesis(\n  homeDir: string,\n  config?: SandboxConfig\n): Promise<void> {\n  // This function modifies the genesis.json file in the specified homeDir\n  await overwriteGenesis(homeDir, config);\n\n  const additionalAccountsWithDefault: GenesisAccount[] = [\n    GenesisAccount.createDefault(),\n    ...(config?.additionalAccounts ?? [])\n  ];\n  // This function create an {accountId}.json file in the homeDir for each account\n  await saveAccountsKeys(homeDir, additionalAccountsWithDefault);\n}\n\nexport async function setSandboxConfig(homeDir: string, config?: SandboxConfig): Promise<void> {\n  // get NEAR_SANDBOX_MAX_PAYLOAD_SIZE and NEAR_SANDBOX_MAX_OPEN_FILES from config or environment variables\n  // If not provided, use default values\n  const maxPayloadSize =\n    config?.additionalGenesis?.[\"maxPayloadSize\"] ??\n    1024 * 1024 * 1024;\n\n  const maxOpenFiles =\n    config?.additionalGenesis?.[\"maxOpenFiles\"] ?? 3000;\n\n  // create a json with these values\n  let newJsonConfig: Record<string, any> = {\n    rpc: {\n      limits_config: {\n        json_payload_max_size: maxPayloadSize,\n      },\n    },\n    store: {\n      max_open_files: maxOpenFiles,\n    },\n  };\n\n  // if there is additionalConfig, merge it with the json\n  if (config?.additionalConfig) {\n    newJsonConfig = apply(newJsonConfig, config?.additionalConfig);\n  }\n\n  // overwrite the sandbox.json file in the homeDir\n  await overwriteSandboxConfigJson(homeDir, newJsonConfig);\n}\n\nasync function overwriteGenesis(\n  homeDir: string,\n  config?: SandboxConfig\n): Promise<void> {\n  const genesisPath = join(homeDir, 'genesis.json');\n  const genesisRaw = await fs.readFile(genesisPath, 'utf-8');\n  const genesisObj = JSON.parse(genesisRaw);\n\n  let totalSupply = BigInt(genesisObj['total_supply']);\n  if (totalSupply === null || totalSupply === undefined) {\n    throw new TypedError(\"Total supply not found in default genesis.json\", SandboxErrors.InvalidConfig);\n  }\n\n  const accountsToAdd: GenesisAccount[] = [\n    GenesisAccount.createDefault(),\n    ...(config?.additionalAccounts ?? [])\n  ];\n\n  for (const account of accountsToAdd) {\n    totalSupply += account.balance;\n  }\n  genesisObj['total_supply'] = totalSupply.toString();\n\n  if (!Array.isArray(genesisObj['records'])) {\n    throw new TypedError(\"Expected 'records' to be an array in default genesis.json\", SandboxErrors.InvalidConfig);\n  }\n\n  for (const acc of accountsToAdd) {\n    genesisObj['records'].push({\n      Account: {\n        account_id: acc.accountId,\n        account: {\n          amount: acc.balance.toString(),\n          locked: \"0\",\n          code_hash: \"11111111111111111111111111111111\",\n          storage_usage: 182\n        }\n      }\n    });\n\n    genesisObj['records'].push({\n      AccessKey: {\n        account_id: acc.accountId,\n        public_key: acc.publicKey,\n        access_key: {\n          nonce: 0,\n          permission: \"FullAccess\"\n        }\n      }\n    });\n  }\n\n  if (config?.additionalGenesis) {\n    apply(genesisObj, config?.additionalGenesis);\n  }\n  await fs.writeFile(genesisPath, JSON.stringify(genesisObj), 'utf-8');\n}\n\nasync function saveAccountsKeys(homeDir: string, additionalAccountsWithDefault: GenesisAccount[]) {\n  for (const account of additionalAccountsWithDefault) {\n    const keyJson = {\n      account_id: account.accountId,\n      public_key: account.publicKey,\n      private_key: account.privateKey\n    };\n\n    const fileName = `${account.accountId}.json`;\n    const filePath = join(homeDir, fileName);\n    const keyContent = JSON.stringify(keyJson, null, 2);\n\n    await fs.writeFile(filePath, keyContent, 'utf-8');\n  }\n}\n\nasync function overwriteSandboxConfigJson(homeDir: string, jsonConfig: Record<string, any>) {\n  const sandboxPath = join(homeDir, 'config.json');\n  const sandboxRaw = await fs.readFile(sandboxPath, 'utf-8');\n  const sandboxObj = JSON.parse(sandboxRaw);\n\n  apply(sandboxObj, jsonConfig);\n  await fs.writeFile(sandboxPath, JSON.stringify(sandboxObj), 'utf-8');\n}\n\n","export enum SandboxErrors {\n    InitializationFailed = \"InitializationFailed\",\n    RunFailed = \"RunFailed\",\n    TearDownFailed = \"TearDownFailed\",\n    InvalidConfig = \"InvalidConfig\",\n}\n\nexport enum BinaryErrors {\n    RunningFailed = \"RunningFailed\",\n    DownloadFailed = \"DownloadFailed\",\n    BinaryNotFound = \"BinaryNotFound\",\n    InstallationFailed = \"InstallationFailed\",\n}\n\nexport enum TcpAndLockErrors {\n    PortNotAvailable = \"PortNotAvailable\",\n    LockFailed = \"LockFailed\",\n    PortAcquisitionFailed = \"PortAcquisitionFailed\",\n}\n\nexport class TypedError extends Error {\n    type: SandboxErrors | BinaryErrors | TcpAndLockErrors | \"UntypedError\";\n    cause?: Error;\n    constructor(message?: string, type?: SandboxErrors | BinaryErrors | TcpAndLockErrors | \"UntypedError\", cause?: Error) {\n        super(message);\n        this.type = type || \"UntypedError\";\n        this.cause = cause;\n    }\n}","import { stat} from \"fs/promises\";\nimport * as os from \"os\";\nimport { DEFAULT_NEAR_SANDBOX_VERSION } from \"../sandbox/Sandbox\";\n\nfunction getPlatform() {\n  const type = os.type();\n  const arch = os.arch();\n\n  // Darwind x86_64 is not supported for quite some time :(\n  if (type === \"Linux\" && arch === \"x64\") {\n    return [type, \"x86_64\"];\n  } else if (type === \"Darwin\" && arch === \"arm64\") {\n    return [type, \"arm64\"];\n  }\n\n  throw new Error(\"Only linux-x86 and darwin-arm are supported\");\n}\n\nexport function AWSUrl(version: string = DEFAULT_NEAR_SANDBOX_VERSION): string {\n  const [platform, arch] = getPlatform();\n  return `https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore/${platform}-${arch}/${version}/near-sandbox.tar.gz`;\n}\n\nexport async function fileExists(filePath: string): Promise<boolean> {\n  try {\n    const f = await stat(filePath);\n    return f.isFile();\n  } catch {\n    return false;\n  }\n}\n","import { fileExists } from \"./binaryUtils\";\nimport { ChildProcess, spawn, StdioOptions } from \"child_process\";\nimport { ensureBinWithVersion } from \"./binary\";\nimport { join } from \"path\";\nimport { TypedError } from \"../errors\";\n\n// initializes a sandbox with the specified version in the provided directory path\nexport async function initConfigsWithVersion(version: string, dirPath: string): Promise<void> {\n    const bin = await ensureBinWithVersion(version);\n\n    const result = spawn(bin, [\"--home\", dirPath, \"init\", \"--fast\"], { stdio: [null, null, \"pipe\"] });\n    await new Promise<void>((resolve, reject) => {\n        result.on(\"close\", (code) => {\n            if (code === 0) resolve();\n            else reject();\n        });\n\n        result.on(\"error\", (error) => {\n            reject(error);\n        });\n    });\n    const expectedFiles = [\"config.json\", \"genesis.json\"];\n\n    for (const filename of expectedFiles) {\n        const filePath = join(dirPath, filename);\n        if (await fileExists(filePath)) continue;\n        throw new Error(`Expected file \"${filename}\" was not created in ${dirPath}`);\n    }\n}\n\nexport async function spawnWithArgsAndVersion(\n    version: string,\n    args: string[],\n    stdio: StdioOptions = ['ignore', 'ignore', 'pipe']\n): Promise<ChildProcess> {\n    const binPath = await ensureBinWithVersion(version);\n\n    const isDebug = process.env['NEAR_ENABLE_SANDBOX_LOG'] === \"1\";\n    const child = spawn(binPath, args, {\n        stdio: isDebug ? \"inherit\" : stdio\n    });\n\n\n    if (!isDebug) {\n        child.stderr?.on(\"error\", (chunk) => {\n            console.error(`Sandbox stderr: ${chunk.toString()}`);\n        });\n    }\n    child.on(\"error\", (err) => {\n        throw new TypedError(\n            `Failed to spawn sandbox process: ${err}`,\n            \"UntypedError\",\n            err instanceof Error ? err : new Error(String(err))\n        );\n    });\n    return child;\n}\n","import { AWSUrl, fileExists } from \"./binaryUtils\";\nimport { join } from \"path\";\nimport { promisify } from \"util\";\nimport * as stream from \"stream\";\nimport * as tar from \"tar\";\nimport got from \"got\";\nimport { existsSync } from \"fs\";\nimport { lock } from \"proper-lockfile\";\nimport * as fs from \"fs/promises\";\nimport { spawn } from \"child_process\";\nimport { BinaryErrors, TcpAndLockErrors, TypedError } from \"../errors\";\nimport { dir } from \"tmp-promise\";\n\nconst pipeline = promisify(stream.pipeline);\n\nexport async function downloadBin(version: string): Promise<string> {\n    const existingFile = await checkForVersion(version);\n    if (existingFile) {\n        return existingFile;\n    }\n    let url: string;\n    const fromEnv = process.env[\"SANDBOX_ARTIFACT_URL\"];\n    if (fromEnv) {\n        url = fromEnv;\n    } else {\n        url = AWSUrl(version);\n    }\n    const dirToDownload = await dir();\n    try {\n        await pipeline(\n            got.stream(url),\n            new stream.PassThrough(),\n            tar.x({ strip: 1, C: dirToDownload.path })\n        );\n\n        const pathToDownloadedFile = join(dirToDownload.path, \"near-sandbox\");\n        const destinationFilePath = join(\n            await getDownloadPath(version),\n            \"near-sandbox\"\n        ); await fs.rename(pathToDownloadedFile, destinationFilePath);\n\n    } catch (error) {\n        throw new TypedError(`Failed to download binary. Check Url and version`,\n            BinaryErrors.DownloadFailed,\n            error instanceof Error ? error : new Error(String(error)));\n    }\n\n    const binPath = join(await getDownloadPath(version), \"near-sandbox\");\n    return binPath;\n}\n\n// Returns a path to the directory where the binary will be downloaded\n// If the arg DIR_TO_DOWNLOAD_BINARY is not undefined directory will be created in the specified path\n// otherwise it will be created in the bin directory of the project\nasync function getDownloadPath(version: string): Promise<string> {\n    const baseDir = process.env[\"DIR_TO_DOWNLOAD_BINARY\"]\n        ?? join(__dirname, \"..\", \"..\", \"bin\");\n    const dirToDownloadBin = join(baseDir, `near-sandbox-${version}`);\n\n    await fs.mkdir(dirToDownloadBin, { recursive: true });\n    return dirToDownloadBin;\n}\n\nexport async function binPath(version: string): Promise<string> {\n    const pathFromEnv = process.env[\"NEAR_SANDBOX_BIN_PATH\"];\n\n    if (pathFromEnv) {\n        if (!(existsSync(pathFromEnv))) {\n            throw new TypedError(`NEAR_SANDBOX_BIN_PATH does not exist.`,\n                BinaryErrors.BinaryNotFound,\n                new Error(`${pathFromEnv} does not exist`)\n            );\n        }\n        return pathFromEnv;\n    }\n\n    const binPath = getDownloadPath(version).then((dir) => join(dir, \"near-sandbox\"));\n    return binPath;\n}\n\nexport async function checkForVersion(version: string): Promise<string | undefined> {\n    const fromEnv = process.env[\"NEAR_SANDBOX_BIN_PATH\"];\n    if (fromEnv) {\n        return fromEnv;\n    }\n\n    const downloadPath = await getDownloadPath(version);\n    const binPath = join(downloadPath, \"near-sandbox\");\n\n    if (await fileExists(binPath)) {\n        return binPath;\n    }\n    return undefined;\n}\n\nexport async function installable(binPath: string): Promise<(() => Promise<void>) | null> {\n    if (existsSync(binPath)) {\n        return null;\n    }\n\n    const lockPath = `${binPath}.lock`;\n\n    let release: () => Promise<void>;\n\n    try {\n\n        if (!existsSync(lockPath)) {\n            await fs.writeFile(lockPath, '');\n        }\n        release = await lock(lockPath, {\n            retries: {\n                retries: 100,\n                factor: 3,\n                minTimeout: 200,\n                maxTimeout: 2 * 1000,\n                randomize: true,\n            },\n        });\n    } catch (error) {\n        throw new TypedError(`Failed to acquire lock for downloading the binary.`,\n            TcpAndLockErrors.LockFailed,\n            error instanceof Error ? error : new Error(String(error))\n        );\n    }\n\n    if (existsSync(binPath)) {\n        await release();\n        return null;\n    }\n\n    return release;\n}\n\nasync function pingBin(binPath: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n        const proc = spawn(binPath, [\"--version\"]);\n\n        let errorOutput = \"\";\n        proc.stderr.on(\"data\", chunk => errorOutput += chunk.toString());\n\n        proc.on(\"error\", err => {\n            reject(err);\n        });\n\n        proc.on(\"exit\", (code, signal) => {\n            if (code === 0) {\n                resolve();\n            } else if (signal) {\n                reject(new Error(`Binary was terminated by signal: ${signal}`));\n            } else {\n                reject(new Error(`Binary exited with code ${code}. Stderr: ${errorOutput}`));\n            }\n        });\n    });\n}\n\nexport async function ensureBinWithVersion(version: string): Promise<string> {\n    let _binPath = await binPath(version);\n    const release = await installable(_binPath);\n\n    if (release) {\n        _binPath = await downloadBin(version);\n        process.env[\"NEAR_SANDBOX_BIN_PATH\"] = _binPath;\n\n        await release();\n    }\n    try {\n        await pingBin(_binPath);\n    } catch (error) {\n        throw new TypedError(`Binary doesn't respond, probably is corrupted. Try re-downloading`,\n            BinaryErrors.RunningFailed,\n            error instanceof Error ? error : new Error(String(error))\n        );\n    }\n    return _binPath;\n}\n","import { existsSync } from \"fs\";\nimport * as fs from \"fs/promises\";\nimport * as net from \"net\";\nimport { join } from \"path\";\nimport { tmpdir } from \"os\";\nimport { lock } from 'proper-lockfile';\nimport { TcpAndLockErrors, TypedError } from \"../errors\";\nimport { spawnWithArgsAndVersion } from \"../binary/binaryExecution\";\nimport { readFile } from \"fs/promises\";\nimport { dir } from \"tmp-promise\";\nimport { DEFAULT_NEAR_SANDBOX_VERSION } from \"./Sandbox\";\n\nconst DEFAULT_RPC_HOST = '127.0.0.1';\n\nexport function rpcSocket(port: number): string {\n    return `${DEFAULT_RPC_HOST}:${port}`;\n}\n\nexport async function acquireOrLockPort(port?: number): Promise<{ port: number; lockFilePath: string }> {\n    return port\n        ? tryAcquireSpecificPort(port)\n        : acquireUnusedPort();\n}\n\nasync function tryAcquireSpecificPort(port: number): Promise<{ port: number; lockFilePath: string }> {\n    const checkedPort = await resolveAvailablePort({ port, host: DEFAULT_RPC_HOST });\n\n    if (checkedPort !== port) {\n        throw new TypedError(`Port ${port} is not available`, TcpAndLockErrors.PortNotAvailable);\n    }\n\n    const lockFilePath = await createLockFileForPort(port);\n\n    try {\n        await lock(lockFilePath);\n        return { port, lockFilePath };\n    } catch {\n        throw new TypedError(`Failed to lock port ${port}. It may already be in use.`, TcpAndLockErrors.LockFailed);\n    }\n}\n\nasync function acquireUnusedPort(): Promise<{ port: number; lockFilePath: string }> {\n    const errors: string[] = [];\n    const MAX_ATTEMPTS = 10;\n\n    for (let i = 0; i < MAX_ATTEMPTS; i++) {\n        try {\n            const port = await resolveAvailablePort({ port: 0, host: DEFAULT_RPC_HOST });\n            const lockFilePath = await createLockFileForPort(port);\n            await lock(lockFilePath);\n            return { port, lockFilePath };\n        } catch (error) {\n            errors.push(error instanceof Error ? error.message : String(error));\n        }\n    }\n    throw new TypedError(\n        `Failed to acquire an unused port after ${MAX_ATTEMPTS} attempts`,\n        TcpAndLockErrors.PortAcquisitionFailed,\n        new Error(errors.map((msg, i) => `Attempt ${i + 1}: ${msg}`).join(\"\\n\"))\n    );\n}\n\n// options takes the port and host, if port is 0 os will find an available port\nasync function resolveAvailablePort(options: net.ListenOptions): Promise<number> {\n    return new Promise((resolve, reject) => {\n        const server = net.createServer();\n        server.unref();\n        server.on('error', (err) => reject(err));\n\n        server.listen(options, () => {\n            const addr = server.address();\n\n            if (typeof addr === 'object' && addr !== null && typeof addr.port === 'number') {\n                const { port } = addr;\n                server.close(() => resolve(port));\n            } else {\n                server.close();\n                reject(new TypedError('Could not determine assigned port.', TcpAndLockErrors.PortAcquisitionFailed));\n            }\n        });\n    });\n}\n\nasync function createLockFileForPort(port: number): Promise<string> {\n    const lockFilePath = join(tmpdir(), `near-sandbox-port-${port}.lock`);\n\n    if (!existsSync(lockFilePath)) {\n        await fs.writeFile(lockFilePath, '');\n    }\n\n    return lockFilePath;\n}\n\nexport async function dumpStateFromPath(pathToState: string): Promise<{\n    config: Record<string, unknown>;\n    genesis: Record<string, unknown>;\n    nodeKey: Record<string, unknown>;\n    validatorKey: Record<string, unknown>;\n}> {\n    await new Promise<void>(async (resolve, reject) => {\n        const proc = await spawnWithArgsAndVersion(DEFAULT_NEAR_SANDBOX_VERSION, [\"--home\", pathToState, \"view-state\", \"dump-state\", \"--stream\"]);\n        proc.on(\"error\", reject);\n        proc.on(\"exit\", (code) => {\n            if (code === 0) {\n                resolve();\n            } else {\n                reject(new Error(`Process exited with code ${code}`));\n            }\n        });\n    });\n\n    const [genesis, config, nodeKey, validatorKey, records] = await Promise.all([\n        readFile(join(pathToState, \"output/genesis.json\"), \"utf-8\").then(JSON.parse),\n        readFile(join(pathToState, \"output/config.json\"), \"utf-8\").then(JSON.parse),\n        readFile(join(pathToState, \"output/node_key.json\"), \"utf-8\").then(JSON.parse),\n        readFile(join(pathToState, \"output/validator_key.json\"), \"utf-8\").then(JSON.parse),\n        readFile(join(pathToState, \"output/records.json\"), \"utf-8\").then(JSON.parse)\n    ]);\n\n    if (!Array.isArray(genesis.records)) genesis.records = [];\n\n    genesis.records.push(...records);\n    return {\n        config,\n        genesis,\n        nodeKey,\n        validatorKey\n    };\n}\n\nexport async function createTmpDir() {\n    const now = new Date();\n    const timestamp = `${String(now.getMonth() + 1).padStart(2, \"0\")}-${String(now.getDate()).padStart(2, \"0\")}_${String(now.getHours()).padStart(2, \"0\")}-${String(now.getMinutes()).padStart(2, \"0\")}`;\n    const random = Math.random().toString(36).substring(2, 8);\n    const name = `near-sandbox-${timestamp}-${random}`;\n\n    return dir({ unsafeCleanup: true, name });\n}\n","import { DirectoryResult } from \"tmp-promise\";\nimport { initConfigsWithVersion, spawnWithArgsAndVersion } from \"../binary/binaryExecution\";\nimport { overrideConfigs, SandboxConfig } from \"./config\";\nimport { ChildProcess } from \"child_process\";\nimport { acquireOrLockPort, createTmpDir, dumpStateFromPath, rpcSocket } from \"./sandboxUtils\";\nimport { unlock } from \"proper-lockfile\";\nimport { rm } from \"fs/promises\";\nimport { SandboxErrors, TypedError } from \"../errors\";\nimport got from \"got\";\n\nexport const DEFAULT_NEAR_SANDBOX_VERSION = \"2.9.0\";\n\ninterface StartParams {\n    config?: SandboxConfig;\n    version?: string;\n}\n/**\n * `Sandbox` provides an isolated, ephemeral NEAR blockchain environment for local testing.\n *\n * Internally, it wraps the execution of the `near-sandbox` binary with configuration options,\n * port locking, and lifecycle management. It ensures proper startup and teardown for reliable testing.\n *\n * @example\n * ```ts\n * import { Sandbox } from './sandbox';\n *\n * const sandbox = await Sandbox.start({\n *   config: {\n *     rpcPort: 3030,\n *     additionalGenesis: { epoch_length: 250 },\n *   }\n * });\n *\n * console.log('Sandbox running at', sandbox.rpcUrl);\n * // Use the sandbox...\n * await sandbox.tearDown(true); // Cleans up temp dir and releases ports\n * ```\n *\n * @property rpcUrl - The URL of the running sandbox's RPC endpoint.(e.g. \"http://127.0.0.1:{port}\")\n * @property homeDir - The path to the temporary home directory used by the sandbox.\n * This directory contains all the sandbox state, configuration and accounts keys.\n * @property rpcPortLockPath - Path to the lock file that prevents other processes from using the same RPC port until this sandbox is started.\n * @property netPortLockPath - Path to the lock file for the network port.\n */\nexport class Sandbox {\n    public readonly rpcUrl: string;\n    public readonly homeDir: string;\n    public readonly rpcPortLockPath: string;\n    public readonly netPortLockPath: string;\n    private childProcess: ChildProcess;\n\n    private constructor(rpcUrl: string, homeDir: string, childProcess: ChildProcess, rpcPortLock: string, netPortLock: string) {\n        this.rpcUrl = rpcUrl;\n        this.homeDir = homeDir;\n        this.rpcPortLockPath = rpcPortLock;\n        this.netPortLockPath = netPortLock;\n        this.childProcess = childProcess;\n    }\n\n    /**\n    * Launch a sandbox environment.\n    *\n    * Downloads the appropriate binary version (if not cached), locks two available ports (RPC & network),\n    * generates a temporary home directory, and spawns the `neard-sandbox` binary with runtime args.\n    *\n    * @param params Configuration options:\n    *   - `config` - Optional sandbox configuration like RPC port, additional genesis data, accounts etc.\n    *   - `version` - Optional NEAR sandbox binary version.\n    *\n    * @returns A ready-to-use `Sandbox` instance with `.rpcUrl` and `.homeDir` available.\n    *\n    * @throws {TypedError} if the sandbox fails to start, ports cannot be locked, or config setup fails.\n    */\n    static async start(params: StartParams): Promise<Sandbox> {\n        const config: SandboxConfig = params.config || {};\n        const version: string = params.version || DEFAULT_NEAR_SANDBOX_VERSION;\n        // Ensure Binary downloaded with specified version\n        // Initialize tmp directory with the specified version\n        // get tmp directory with default configs\n        const tmpDir = await this.initConfigsWithVersion(version);\n        // get ports\n        const { port: rpcPort, lockFilePath: rpcPortLock } = await acquireOrLockPort(config?.rpcPort);\n        const { port: netPort, lockFilePath: netPortLock } = await acquireOrLockPort(config?.netPort);\n\n        const rpcAddr = rpcSocket(rpcPort);\n        const netAddr = rpcSocket(netPort);\n        // set sandbox configs\n        await overrideConfigs(tmpDir.path, config);\n        // create options and args to spawn the process\n        const args = [\"--home\", tmpDir.path, \"run\", \"--rpc-addr\", rpcAddr, \"--network-addr\", netAddr];\n        // spawn sandbox with the specified version and arguments, get ChildProcess\n        const childProcess = await spawnWithArgsAndVersion(version, args);\n\n        const rpcUrl = `http://${rpcAddr}`;\n\n        // Ping rpcUrl to ensure the process is ready\n        await this.waitUntilReady(rpcUrl);\n\n        return new Sandbox(rpcUrl, tmpDir.path, childProcess, rpcPortLock, netPortLock);\n    }\n\n    /**\n     * Dumps the current state of the sandbox environment.\n     * Parses next files from dumped dir: the genesis, records(that will merge to genesis), config, node_key, and validator_key.\n     *\n     * Returned files such as `genesis`, `nodeKey`, and `validatorKey` are intended to be used\n     * when running the sandbox with a specific state. These files contain the necessary configuration and keys\n     * to restore or replicate the sandbox environment.\n     * @returns An object containing the genesis, config, node key, and validator key as json files.\n     */\n    async dump(): Promise<{\n        config: Record<string, unknown>;\n        genesis: Record<string, unknown>;\n        nodeKey: Record<string, unknown>;\n        validatorKey: Record<string, unknown>;\n    }> {\n        return dumpStateFromPath(this.homeDir);\n    }\n\n    /**\n     * Destroys the running sandbox environment by:\n     * - Killing the child process, waiting for it to exit\n     * - Unlocking the previously locked ports\n     */\n    async stop(): Promise<void> {\n        this.childProcess.kill();\n\n        await new Promise(resolve => this.childProcess.once('exit', resolve));\n        await Promise.allSettled([\n            unlock(this.rpcPortLockPath),\n            unlock(this.netPortLockPath)\n        ]);\n\n    }\n    /**\n     * Calls `stop()` to terminate the sandbox and then cleans up the home directory.\n     */\n    async tearDown(): Promise<void> {\n        await this.stop();\n        await rm(this.homeDir, { recursive: true, force: true }).catch(error => {\n\n            throw new TypedError(`Sandbox teardown encountered errors`,\n                SandboxErrors.TearDownFailed,\n                error instanceof Error ? error : new Error(String(error)));\n        });\n    }\n\n    private static async initConfigsWithVersion(version: string): Promise<DirectoryResult> {\n        const tmpDir = await createTmpDir();\n        await initConfigsWithVersion(version, tmpDir.path);\n        return tmpDir;\n    }\n\n    private static async waitUntilReady(rpcUrl: string) {\n        const timeoutSecs = parseInt(process.env[\"NEAR_RPC_TIMEOUT_SECS\"] || '10');\n        const attempts = timeoutSecs * 2;\n        let lastError: unknown = null;\n        for (let i = 0; i < attempts; i++) {\n            try {\n                const response = await got(`${rpcUrl}/status`, { throwHttpErrors: false });\n                if (response.statusCode >= 200 && response.statusCode < 300) {\n                    return;\n                }\n            } catch (error) {\n                lastError = error;\n            }\n            await new Promise(resolve => setTimeout(resolve, 500));\n        }\n        throw new TypedError(\"Sandbox failed to become ready within the timeout period.\",\n            SandboxErrors.RunFailed,\n            lastError instanceof Error ? lastError : new Error(String(lastError))\n        );\n    }\n}\n"],"mappings":"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","names":["type","type","arch","spawn","join","fs","pipeline","join","binPath","dir","join","spawn","join","binPath","existsSync","fs","join","lock","readFile","dir","lock","join","existsSync","readFile","dir","got"]}